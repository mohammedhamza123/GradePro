# GradPro

**GradPro** (نظام إدارة مشاريع التخرج) is a cross-platform Flutter application designed to streamline the management, tracking, and evaluation of graduation projects for students, teachers, and administrators. The system supports multi-role access, real-time notifications, and a robust approval workflow, making it suitable for academic institutions.

---

## Table of Contents
- [Project Overview](#project-overview)
- [Features](#features)
- [Project Structure](#project-structure)
- [Setup & Installation](#setup--installation)
- [Usage](#usage)
- [Troubleshooting & Known Issues](#troubleshooting--known-issues)
- [Contributing](#contributing)
- [License](#license)

---

## Project Overview
GradPro helps students, supervisors, and administrators manage graduation projects efficiently. It provides:
- Project proposal, approval, and tracking
- Role-based dashboards for students, teachers, and admins
- Real-time notifications (Firebase)
- Chat and communication features
- PDF and file management
- Evaluation and grading workflows

## Features
- **Multi-role Authentication:** Students, teachers, and admins have distinct dashboards and permissions.
- **Student Project Management:** Students can propose, edit, and track their graduation projects, submit suggestions, and upload files.
- **Teacher Supervision:** Teachers can supervise, evaluate, and communicate with students, and manage project requirements.
- **Admin Control:** Admins can approve/reject students, assign teachers, manage all projects, and oversee the entire workflow.
- **Notifications:** Real-time push notifications using Firebase for important events.
- **Chat System:** In-app chat for communication between users.
- **PDF Viewer:** Integrated PDF viewing and file management.
- **Evaluation System:** Customizable grading and evaluation forms for projects.
- **Arabic Language Support:** UI and error messages are localized for Arabic users.

## Project Structure
- `lib/` - Main Dart source code
  - `main.dart` - App entry point, routing, and provider setup
  - `pages/` - UI pages for each role and feature
  - `providers/` - State management for students, teachers, admins, chat, notifications, etc.
  - `services/` - API, authentication, notification, and utility services
  - `models/` - Data models for users, projects, suggestions, etc.
  - `assets/` - Images and icons
  - `fonts/` - Custom fonts
- `android/`, `ios/`, `web/`, `linux/`, `macos/`, `windows/` - Platform-specific code
- `pubspec.yaml` - Dependencies and asset configuration

## Setup & Installation
### Prerequisites
- [Flutter SDK](https://flutter.dev/docs/get-started/install) (>=3.3.3 <4.0.0)
- Dart SDK (compatible with Flutter version)
- Firebase project (for notifications)
- Internet connection (for backend API)

### Steps
1. **Clone the repository:**
   ```bash
   git clone <repo-url>
   cd grad_project_flutter_new
   ```
2. **Install dependencies:**
   ```bash
   flutter pub get
   ```
3. **Configure Firebase:**
   - Place your `google-services.json` (Android) and `GoogleService-Info.plist` (iOS) in the respective folders.
   - Update `firebase_options.dart` if needed (generated by FlutterFire CLI).
4. **Run the app:**
   ```bash
   flutter run
   ```
   - For web: `flutter run -d chrome`
   - For desktop: `flutter run -d windows` (or `macos`, `linux`)

## Usage
- On first launch, you'll see a welcome screen and can log in as a student, teacher, or admin.
- Students can register, propose projects, and track progress.
- Teachers can view assigned projects, evaluate, and communicate.
- Admins can approve students, assign teachers, and manage all data.
- Notifications and chat are available for real-time updates.

## Troubleshooting & Known Issues
### Common Issues
- **Network Errors:**
  - Ensure backend API (`https://easy0123.pythonanywhere.com`) is reachable.
  - Check your internet connection.
- **Firebase Initialization Fails:**
  - Make sure `google-services.json` and `GoogleService-Info.plist` are correctly placed.
  - Check Firebase project configuration.
- **Student Approval:**
  - Students with numeric usernames require admin approval before accessing features.
  - If you see messages like "حسابك قيد المراجعة" (Your account is under review), contact the admin.
- **Token Expiry:**
  - If you are logged out unexpectedly, your session token may have expired. Log in again.
- **File Upload/Download Issues:**
  - Ensure file size and format are supported.
  - Check backend storage configuration.
- **Notifications Not Received:**
  - Check device notification permissions.
  - Ensure Firebase Cloud Messaging is set up correctly.
- **Arabic Text Display Issues:**
  - Make sure the required fonts are included and configured in `pubspec.yaml`.

### Error Handling
- The app provides user-friendly error messages in Arabic for most common issues.
- Retry buttons are available for network-dependent actions.
- All API errors are logged and surfaced to the user when possible.

### Debugging
- Use `flutter run --verbose` for detailed logs.
- Check the backend logs for API errors.
- For authentication issues, clear app data and re-login.

## Contributing
Contributions are welcome! Please open issues or pull requests for bug fixes, new features, or documentation improvements.

## License
This project is for educational use. Please contact the author for licensing details if you wish to use it commercially. 

## Service Usage in Providers: Analysis & Best Practices

### Overview
This project uses a layered architecture where **services** encapsulate API/network logic and **providers** (extending `ChangeNotifier`) manage state and business logic for the UI. Providers use services to fetch, update, and delete data, then notify listeners (widgets) of changes.

#### Main Service Types
- **UserService**: Handles user, student, and project data for the current session.
- **ImageService**: Handles image uploads.
- **InternetService**: Low-level HTTP client, manages tokens and headers.
- **ModelServices** (`lib/services/models_services.dart`): Contains global async functions for CRUD operations on all models (projects, students, teachers, suggestions, requirements, etc.).
- **NotificationService**: Handles notification logic, both local (device) and remote (API).

### Typical Usage Patterns
- **Providers** instantiate or use singleton services (e.g., `UserService`, `ImageService`).
- Providers call service methods to fetch or mutate data, then update their own state and call `notifyListeners()`.
- Most data-fetching and mutation in providers is done via the global functions in `models_services.dart` (e.g., `getProjectList()`, `postRequirement()`, etc.), not via instance methods on service classes.

### Compatibility & Correctness
#### What Works Well
- **Separation of Concerns**: Providers do not contain direct HTTP logic; all network calls are abstracted in services.
- **Singleton Pattern**: Services like `UserService` and `ImageService` are singletons, ensuring consistent state and avoiding redundant network calls.
- **Token Management**: `InternetService` manages tokens and headers, and is reused across all service calls.
- **Async/Await**: All service calls are asynchronous, which is compatible with Flutter's UI thread.

#### Common Patterns
- Providers often check authorization before making API calls:
  ```dart
  final InternetService services = InternetService();
  if (!services.isAuthorized()) {
    return [];
  }
  ```
- Providers use both instance services (e.g., `UserService`) and global functions (e.g., `getProjectList()`).

#### Potential Issues & Inconsistencies
1. **Direct Use of Global Functions**: Many providers use global functions from `models_services.dart` directly. This is acceptable, but it means that business logic is split between providers and global service functions, which can make testing and maintenance harder.
2. **Bypassing Service Abstractions**: Some providers use both instance services and global functions, which can be confusing. For example, `UserService` caches the current user, but `getMyAccount()` (global) does not.
3. **Redundant Authorization Checks**: Many providers instantiate a new `InternetService` just to check `isAuthorized()`. Since `InternetService` is a singleton, this is not harmful, but it is redundant.
4. **Mixing Model and Service Responsibilities**: Some global functions in `models_services.dart` are very thin wrappers around HTTP calls, while others contain more logic. This can lead to inconsistent error handling and data flow.
5. **Error Handling**: Error handling is inconsistent. Some providers catch and log errors, others just let exceptions propagate. Some service functions throw user-friendly messages, others do not.
6. **State Caching**: `UserService` caches user, student, and project objects, but most other data is not cached and is always fetched fresh.

### Recommendations
1. **Prefer Service Abstractions**: Where possible, encapsulate all model-related logic in service classes (e.g., `UserService`, `ProjectService`) rather than using global functions. This makes testing and maintenance easier.
2. **Consistent Error Handling**: Standardize error handling in both services and providers. Always catch errors in providers and update state accordingly.
3. **Avoid Redundant Checks**: Use the singleton instance of `InternetService` for authorization checks, and avoid unnecessary instantiations.
4. **Centralize Business Logic**: Keep business logic in providers, and keep services focused on data access and network logic.
5. **Document Data Flow**: Clearly document which provider uses which service and for what purpose, to avoid confusion and accidental bypassing of caches or business logic.

#### Example: Correct Usage
```dart
class ExampleProvider extends ChangeNotifier {
  final UserService _userService = UserService();
  User? _user;
  Future<void> loadUser() async {
    try {
      _user = await _userService.user;
      notifyListeners();
    } catch (e) {
      // handle error, update state
    }
  }
}
```

#### Example: Potentially Problematic Usage
```dart
Future<void> loadUser() async {
  // This bypasses UserService's cache and logic
  _user = await getMyAccount();
  notifyListeners();
}
```

### Conclusion
- The current architecture is functional and mostly consistent, but there is room for improvement in abstraction, error handling, and documentation.
- No critical misuses were found, but some patterns (mixing global functions and service instances, inconsistent error handling) could lead to bugs or maintenance issues in the future.

**For maintainers:**
Consider refactoring to use service classes for all model access, and standardize error handling and state management in providers. 